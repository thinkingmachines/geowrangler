# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/15_polygon_fill.ipynb.

# %% auto 0
__all__ = ['voxel_traversal_2d', 'scanline_fill', 'voxel_traversal_scanline_fill']

# %% ../../notebooks/15_polygon_fill.ipynb 5
from typing import List, Tuple, Set, Optional, Dict, Union

import numpy as np
import pandas as pd
import polars as pl

# %% ../../notebooks/15_polygon_fill.ipynb 11
def voxel_traversal_2d(
    start_vertex: Tuple[int, int],
    end_vertex: Tuple[int, int],
    debug: bool = False,  # if true, prints diagnostic info for the algorithm
) -> List[Tuple[int, int]]:
    """
    Returns all pixels between two points as inspired by Amanatides & Woo's “A Fast Voxel Traversal Algorithm For Ray Tracing”
    Implementation adapted from https://www.redblobgames.com/grids/line-drawing/
    """

    # Setup initial conditions
    x1, y1 = start_vertex
    x2, y2 = end_vertex

    direction_x = 1 if x2 > x1 else -1
    direction_y = 1 if y2 > y1 else -1

    # Single point
    if (x1 == x2) and (y1 == y2):
        pixels = [(x1, y1)]
        return pixels

    # Vertical line
    elif x1 == x2:
        pixels = [(x1, y) for y in range(y1, y2 + direction_y, direction_y)]
        return pixels

    # Horizontal line
    elif y1 == y2:
        pixels = [(x, y1) for x in range(x1, x2 + direction_x, direction_x)]
        return pixels

    dy = y2 - y1
    dx = x2 - x1

    pixel_x, pixel_y = x1, y1
    pixels = [(pixel_x, pixel_y)]

    is_finished = False

    if debug:
        print(f"\nTraversing from ({x1},{y1}) to ({x2},{y2})")

    ix = 0
    iy = 0

    nx = abs(dx)
    ny = abs(dy)
    max_steps = nx + ny
    n_steps = 0
    while not is_finished:
        # this prevents infinite loops
        n_steps += 1
        if n_steps > max_steps:
            raise Exception(
                f"Traversal has exceeded steps limit {max_steps:,}. Please recheck inputs"
            )

        decision = (1 + 2 * ix) * ny - (1 + 2 * iy) * nx
        if decision == 0:
            # diagonal step
            pixel_x += direction_x
            pixel_y += direction_y
            ix += 1
            iy += 1
        elif decision < 0:
            # horizontal step
            pixel_x += direction_x
            ix += 1
        else:
            # vetical step
            pixel_y += direction_y
            iy += 1

        pixels.append((pixel_x, pixel_y))

        if debug:
            print(f"Next tile coords are ({pixel_x}, {pixel_y})")

        # checks to see if the loop is finished
        if direction_x == 1:
            is_x_finished = pixel_x >= x2
        elif direction_x == -1:
            is_x_finished = pixel_x <= x2

        if direction_y == 1:
            is_y_finished = pixel_y >= y2
        elif direction_y == -1:
            is_y_finished = pixel_y <= y2

        if is_x_finished and is_y_finished:
            break

    return pixels

# %% ../../notebooks/15_polygon_fill.ipynb 15
def interpolate_x(
    start_vertex: Tuple[int, int],
    end_vertex: Tuple[int, int],
    y: int,
) -> float:
    """Interpolate x value for a given y along the line segment defined by start_vertex and end_vertex."""
    x1, y1 = start_vertex
    x2, y2 = end_vertex
    if y1 == y2:
        # case when there is a horizontal line segment
        raise ValueError(f"The y value of the 2 vertices should not be the same")

    inverse_slope = (x2 - x1) / (y2 - y1)
    interpolated_x = x1 + (y - y1) * inverse_slope
    return interpolated_x

# %% ../../notebooks/15_polygon_fill.ipynb 16
def scanline_fill(
    vertices: List[
        Tuple[int, int]
    ],  # list of polygon vertices in order (either clockwise or counterclockwise)
    debug: bool = False,  # if true, prints diagnostic info for the algorithm
) -> Set[Tuple[int, int]]:
    """Returns all pixels within the interior of a polygon defined by vertices"""

    offset_vertices = vertices[1:] + vertices[:1]

    if not vertices:
        return set()

    if len(vertices) == 1:
        return set(vertices)

    # Calculate the bounding box for the polygon
    min_y, max_y = min(y for x, y in vertices), max(y for x, y in vertices)

    filled_pixels = set()
    # Process each horizontal scanline within the bounding box
    for scanline_y in range(min_y, max_y + 1):
        intersection_points = []

        # Find intersections of the polygon with the current scanline
        for start_vertex, end_vertex in zip(vertices, offset_vertices):
            start_x, start_y = start_vertex
            end_x, end_y = end_vertex

            if (end_y < scanline_y <= start_y) or (start_y < scanline_y <= end_y):
                # Calculate x-coordinate of intersection
                intersection_x = interpolate_x(start_vertex, end_vertex, scanline_y)
                intersection_points.append(intersection_x)

        # Fill pixels between pairs of intersections
        if intersection_points:
            intersection_points.sort()

            filled_pixels_in_row = set()
            for start_x, end_x in zip(
                intersection_points[::2], intersection_points[1::2]
            ):
                start_x, end_x = int(round(start_x)), int(round(end_x))

                _filled_pixels_in_row = [
                    (x, scanline_y) for x in range(start_x, end_x + 1)
                ]
                filled_pixels_in_row.update(_filled_pixels_in_row)

            filled_pixels.update(filled_pixels_in_row)

        if debug:
            print(f"Scanline y = {scanline_y}, Intersections: {intersection_points}")

    return filled_pixels

# %% ../../notebooks/15_polygon_fill.ipynb 20
def voxel_traversal_scanline_fill(
    vertices_df: Union[
        pd.DataFrame, pl.DataFrame
    ],  # dataframe with x_col and y_col for the polygon vertices
    x_col: str = "x",
    y_col: str = "y",
    debug: bool = False,  # if true, prints diagnostic info for both voxel traversal and scanline fill algorithms
) -> Set[Tuple[int, int]]:
    """
    Returns pixels that intersect a polygon
    This uses voxel traversal to fill the boundary, and scanline fill for the interior. All coordinates are assumed to be nonnegative integers
    """

    vertices = list(zip(vertices_df[x_col].to_list(), vertices_df[y_col].to_list()))
    offset_vertices = vertices[1:] + vertices[:1]

    polygon_pixels = set()

    for start_vertex, end_vertex in zip(vertices, offset_vertices):
        polygon_pixels.update(voxel_traversal_2d(start_vertex, end_vertex, debug))

    polygon_pixels.update(scanline_fill(vertices, debug))

    return polygon_pixels
