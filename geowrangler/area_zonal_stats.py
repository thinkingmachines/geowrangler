# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/04_area_zonal_stats.ipynb (unless otherwise specified).

__all__ = ["create_area_zonal_stats"]


# Cell
import geopandas as gpd

# import numpy as np
# import pandas as pd
# import geowrangler.vector_zonal_stats as vzs

# Internal Cell
def prep_aoi(aoi):
    aoi = aoi.copy()
    aoi.index.name = "aoi_index"
    aoi.reset_index(level=0, inplace=True)
    return aoi


# Internal Cell
def extract_func(func):
    extra = []
    if func.__contains__("raw_"):
        extra += ["raw"]
        func = func.replace("raw_", "")
    if func.__contains__("imputed_"):
        extra += ["imputed"]
        func = func.replace("imputed_", "")
    return func, extra


# Internal Cell
def fix_area_agg(agg):
    if "func" not in agg:
        return agg  # skip fix as agg spec is invalid

    if type(agg["func"]) == str:
        agg["func"] = [agg["func"]]

    real_funcs = []
    func_extras = []
    for func in agg["func"]:
        real_func, extra = extract_func(func)
        real_funcs += [real_func]
        func_extras += [extra]
    agg["func"] = real_funcs
    agg["extras"] = func_extras

    # optional column, default to index count
    if "column" not in agg:
        agg["column"] = "aoi_index"

    if "output" not in agg:
        column = "index" if agg["column"] == "aoi_index" else agg["column"]
        agg["output"] = [f"{column}_{f}" for f in agg["func"]]

    if type(agg["output"]) == str:
        agg["output"] = [agg["output"]]

    # check matching fillna
    if "fillna" not in agg:
        agg["fillna"] = [False for _ in agg["func"]]

    if type(agg["fillna"]) == bool:
        agg["fillna"] = [agg["fillna"]]

    return agg


# Internal Cell


def get_source_column(agg):

    if "raw" in agg["extras"]:
        return agg["column"]  # dont use intersect column

    intersect_data_column = f"intersect_data_{agg['column']}"
    intersect_aoi_column = f"intersect_aoi_{agg['column']}"

    if agg["func"] in ("sum", "count"):
        return intersect_data_column

    return intersect_aoi_column


# Internal Cell
INTERSECT_AREA_AGG = {
    "column": "intersect_area",
    "func": "sum",
    "output": "intersect_area_sum",
    "extras": "raw",
}

# Internal Cell
def build_agg_area_dicts(aggs):
    aggs = [INTERSECT_AREA_AGG, *aggs]
    agg_dicts = {agg["output"]: (get_source_column(agg), agg["func"]) for agg in aggs}
    return agg_dicts


# Internal Cell


def validate_area_aoi(aoi):
    if aoi.crs.is_geographic:
        raise ValueError(
            f"aoi has geographic crs: {aoi.crs}, areas maybe incorrectly computed"
        )


# Internal Cell


def validate_area_data(data):
    if data.crs.is_geographic:
        raise ValueError(
            f"data has geographic crs: {data.crs}, areas maybe incorrectly computed"
        )


# Internal Cell
def validate_area_aggs(fixed_aggs):
    pass


# Internal Cell


def expand_area_aggs(aggs):
    expanded_aggs = []
    for agg in aggs:
        for i, func in enumerate(agg["func"]):
            expanded_agg = {
                "func": func,
                "column": agg["column"],
                "output": agg["output"][i],
                "fillna": agg["fillna"][i],
                "extras": agg["extras"][i],
            }
            expanded_aggs += [expanded_agg]
    return expanded_aggs


# Internal Cell
def compute_intersect_stats(intersect, expanded_aggs):
    # optimization - use df.apply to create all new columns simultaneously
    for agg in expanded_aggs:
        if "raw" in agg["extras"]:
            pass  # dont use intersect stat
        intersect_data_column = f"intersect_data_{agg['column']}"
        intersect_aoi_column = f"intersect_aoi_{agg['column']}"
        if intersect_data_column not in intersect.columns.values:
            intersect[intersect_data_column] = (
                intersect["pct_data"] * intersect[agg["column"]]
            )
        if intersect_aoi_column not in intersect.columns.values:
            intersect[intersect_aoi_column] = (
                intersect["pct_aoi"] * intersect[agg["column"]]
            )
    return intersect


# Internal Cell
def compute_imputed_stats(results, expanded_aggs):
    # optimize with df.apply
    # handle when intersect_area_sum is np.nan
    for agg in expanded_aggs:
        if "imputed" in agg["extras"]:
            results[agg["output"]] = (
                results[agg["output"]] / results[INTERSECT_AREA_AGG["output"]]
            )


# Cell
def create_area_zonal_stats(
    aoi: gpd.GeoDataFrame, data: gpd.GeoDataFrame, aggregations, include_intersect=True
):

    validate_area_aoi(aoi)
    validate_area_data(data)

    fixed_aggs = [fix_area_agg(agg) for agg in aggregations]

    validate_area_aggs(fixed_aggs)

    # reindex aoi
    aoi_index_name = aoi.index.name
    aoi = prep_aoi(aoi)
    data = data.copy()

    if not data.crs.equals(aoi.crs):
        data = data.to_crs(aoi.crs)

    # compute aoi and data areas
    aoi["aoi_area"] = aoi.geometry.area
    data["data_area"] = data.geometry.area

    # add spatial indexes
    aoi.geometry.sindex
    data.geometry.sindex

    # dissolve (merge data polygons?)
    # spatial join (remove non-intersecting aoi? remove non-intersecting data)
    # overlay defaults = how='intersection', keep_geom_type=None, make_valid=True
    intersect = aoi.overlay(data, keep_geom_type=True)

    # compute intersect area and percentages
    intersect["intersect_area"] = intersect.geometry.area
    intersect["pct_data"] = intersect["intersect_area"] / intersect["data_area"]
    intersect["pct_aoi"] = intersect["intersect_area"] / intersect["aoi_area"]

    expanded_aggs = expand_area_aggs(fixed_aggs)
    intersect = compute_intersect_stats(intersect, expanded_aggs)

    groups = intersect.groupby("aoi_index")

    agg_area_dicts = build_agg_area_dicts(expanded_aggs)

    aggregates = groups.agg(**agg_area_dicts)

    results = aoi.merge(aggregates, how="left", on="aoi_index", suffixes=(None, "_y"))

    compute_imputed_stats(results, expanded_aggs)
    drop_labels = ["aoi_area"]
    if not include_intersect:
        drop_labels += [INTERSECT_AREA_AGG["output"]]
    results.drop(labels=drop_labels, inplace=True, axis=1)

    results.set_index("aoi_index", inplace=True)
    results.index.name = aoi_index_name
    return results
