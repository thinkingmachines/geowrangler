# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_vector_zonal_stats.ipynb (unless otherwise specified).

__all__ = ["_fix_agg", "_prep_aoi", "_aggregate_stats", "create_zonal_stats"]

# Internal Cell
import warnings

warnings.filterwarnings(action="ignore", category=UserWarning, module="geopandas")

# Internal Cell
from typing import Any, Dict
import geopandas as gpd
import pandas as pd

# Cell
# nbdev_comment _all_ = ["_fix_agg", "_prep_aoi", "_aggregate_stats"]

# Internal Cell
def _fix_agg(
    agg: Dict[str, Any],  # A dict containing at the minimum a 'func' key
) -> Dict[str, Any]:
    """
    Validate and (possibly) fix an `agg spec`.

    It outputs a dict containing the following keys:
      - 'func': a list of aggregation functions (should be a valid 'agg' function)
      - 'column': a column to apply the aggregation functions (should be a valid numeric column in data)
      - 'output': the names of the new columns containing the application of the aggregation functions (default: concat column + '_' + func)
      - 'fillna': boolean list whether to replace new columns with 'NA' values  with 0 (default: True)
    """
    if "func" not in agg:
        raise ValueError(f"Missing key 'func' for agg {agg}")

    if type(agg["func"]) == str:
        agg["func"] = [agg["func"]]

    # optional column, default to index count
    if "column" not in agg:
        agg["column"] = "aoi_index"

    # check matching output
    if "output" not in agg:
        agg["output"] = [f'{agg["column"]}_{f}' for f in agg["func"]]
    if type(agg["output"]) == str:
        agg["output"] = [agg["output"]]
    if len(agg["output"]) != len(agg["func"]):
        raise ValueError(
            f"output list {agg['output']} doesn't match func list {agg['func']}"
        )

    # check matching fillna
    if "fillna" not in agg:
        agg["fillna"] = [True for o in agg["func"]]

    if len(agg["fillna"]) != len(agg["func"]):
        raise ValueError(
            f"fillna list {agg['fillna']} doesn't match func list {agg['func']}"
        )

    return agg


# Internal Cell


def _prep_aoi(
    aoi: gpd.GeoDataFrame,  # Area of interest
) -> gpd.GeoDataFrame:
    """
    Prepare aoi for spatial join
      - split off any existing columns named index and aoi_index and drop them from aoi
      - create a column 'aoi_index' from aoi's index which will be used as grouping key
    """
    # prep for spatial join
    aoi = aoi.copy()

    # handle existing col named 'index'

    aoi_index_data = None
    if "index" in list(aoi.columns.values):
        aoi_index_data = aoi["index"]
        aoi.drop(labels="index", inplace=True, axis=1)

    # handle existing col named 'aoi_index'

    aoi_col_data = None
    if "aoi_index" in list(aoi.columns.values):
        aoi_col_data = aoi["aoi_index"]
        aoi.drop(labels="aoi_index", inplace=True, axis=1)

    # create index col for broadcast to features
    aoi.reset_index(level=0, inplace=True)
    aoi.rename(columns={"index": "aoi_index"}, inplace=True)
    return aoi, aoi_index_data, aoi_col_data


# Internal Cell


def _aggregate_stats(
    aoi: gpd.GeoDataFrame,  # Area of interest
    groups: pd.core.groupby.DataFrameGroupBy,  # Source data aggregated into groups by 'aoi_index'
    agg: Dict[str, Any],  # An agg spec to be applied
) -> gpd.GeoDataFrame:
    """Aggregate groups and compute agg functions in agg['func'] for agg['column'], map them to output columns in agg['column']
    and merge them back to aoi dataframe
    """
    aggregates = groups[agg["column"]].agg(agg["func"])
    renames = {k: v for k, v in zip(agg["func"], agg["output"])}
    aggregates.rename(columns=renames, inplace=True)
    results = aoi.merge(aggregates, how="left", on="aoi_index", suffixes=(None, "_y"))

    # set NAs to 0 if fillna
    for i, colname in enumerate(agg["output"]):
        if agg["fillna"][i]:
            if colname in list(aoi.columns.values):
                colname = colname + "_y"  # try if merged df has colname + _y
            if colname in list(results.columns.values):
                results[colname].fillna(0, inplace=True)

    return results


# Cell


def create_zonal_stats(
    aoi: gpd.GeoDataFrame,  # Area of interest for which zonal stats are to be computed for
    data: gpd.GeoDataFrame,  # Source gdf containing data to compute zonal stats from
    aggregations: [
        Dict[str, Any]
    ],  # a list of agg specs, with each agg spect applied to a data column
    overlap_method: str = "intersects",  # spatial predicate to used in spatial join of aoi and data [geopandas.sjoin](https://geopandas.org/en/stable/docs/user_guide/mergingdata.html#binary-predicate-joins) for more details
    # categorical_column_options: str = None,
) -> gpd.GeoDataFrame:
    """
    Create zonal stats for area of interest from data using aggregration operations on data columns.
    Returns the same aoi with additional columns containing the computed zonal features.
    """
    # make data crs == aoi crs
    if not data.crs.equals(aoi.crs):
        data = data.to_crs(aoi.crs)

    # prep for spatial join
    aoi, aoi_index_data, aoi_col_data = _prep_aoi(aoi)

    # spatial join - broadcast aoi_index to data => features
    features = gpd.sjoin(
        aoi[["aoi_index", "geometry"]], data, how="inner", predicate=overlap_method
    )

    # group
    groups = features.groupby("aoi_index")
    results = aoi

    # apply aggregations one column at a time
    for agg in aggregations:
        agg = _fix_agg(agg)
        results = _aggregate_stats(results, groups, agg)

    # cleanup results
    results.drop(labels="aoi_index", inplace=True, axis=1)
    if aoi_index_data is not None:
        results["index"] = aoi_index_data
    if aoi_col_data is not None:
        results["aoi_index"] = aoi_col_data

    return results
