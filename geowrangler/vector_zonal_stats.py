# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/02_vector_zonal_stats.ipynb (unless otherwise specified).

__all__ = ["fix_agg", "prep_aoi", "aggregate_stats", "create_zonal_stats"]


# Internal Cell
import geopandas as gpd
import pandas as pd

# Cell
def fix_agg(agg: {}) -> {}:  # A dict containing at the minimum a 'func' key
    """
    Validate and (possibly) Fix an aggregation specification
    and outputs a dict containing the following keys:
    'func': a list of aggregation functions (should be a valid 'agg' function)
    'column': a column to apply the aggregation functions (should be a valid numeric column in data)
    'output': the names of the new columns containing the application of the aggregation functions (default: concat column + '_' + func)
    'fillna': boolean list whether to replace new columns with 'NA' values  with 0 (default: True)
    """
    if "func" not in agg:
        raise ValueError(f"Missing key 'func' for agg {agg}")

    if type(agg["func"]) == str:
        agg["func"] = [agg["func"]]

    # optional column, default to index count
    if "column" not in agg:
        agg["column"] = "aoi_index"

    # check matching output
    if "output" not in agg:
        agg["output"] = [f'{agg["column"]}_{f}' for f in agg["func"]]
    if type(agg["output"]) == str:
        agg["output"] = [agg["output"]]
    if len(agg["output"]) != len(agg["func"]):
        raise ValueError(
            f"output list {agg['output']} doesn't match func list {agg['func']}"
        )

    # check matching fillna
    if "fillna" not in agg:
        agg["fillna"] = [True for o in agg["func"]]

    if len(agg["fillna"]) != len(agg["func"]):
        raise ValueError(
            f"fillna list {agg['fillna']} doesn't match func list {agg['func']}"
        )

    return agg


# Cell
def prep_aoi(aoi: gpd.GeoDataFrame) -> gpd.GeoDataFrame:  # Area of interest
    """
    prepare aoi for spatial join
      - split off any existing columns named index and aoi_index and drop them from aoi
      - create a column 'aoi_index' from aoi index
    """
    # prep for spatial join
    aoi = aoi.copy()

    # handle existing col named 'index'

    aoi_index_data = None
    if "index" in list(aoi.columns.values):
        aoi_index_data = aoi["index"]
        aoi.drop(labels="index", inplace=True, axis=1)

    # handle existing col named 'aoi_index'

    aoi_col_data = None
    if "aoi_index" in list(aoi.columns.values):
        aoi_col_data = aoi["aoi_index"]
        aoi.drop(labels="aoi_index", inplace=True, axis=1)

    # create index col for broadcast to features
    aoi.reset_index(level=0, inplace=True)
    aoi.rename(columns={"index": "aoi_index"}, inplace=True)
    return aoi, aoi_index_data, aoi_col_data


# Cell


def aggregate_stats(
    aoi: gpd.GeoDataFrame,  # Area of interest
    groups: pd.core.groupby.DataFrameGroupBy,  # data aggregated into groups by 'aoi_index'
    agg: {},  # aggregation to be applied for a given column
) -> gpd.GeoDataFrame:
    """Aggregate groups and compute agg functions in agg['func'] for agg['column'], map them to output columns in agg['column']
    and merge them back to aoi
    """
    aggregates = groups[agg["column"]].agg(agg["func"])
    renames = {k: v for k, v in zip(agg["func"], agg["output"])}
    aggregates.rename(columns=renames, inplace=True)
    results = aoi.merge(aggregates, how="left", on="aoi_index", suffixes=(None, "_y"))

    return results


# Cell


def create_zonal_stats(
    aoi: gpd.GeoDataFrame,  # Area of interest for which zonal stats are to be computed for
    data: gpd.GeoDataFrame,  # Source gdf containing data to compute zonal stats from
    # data_type: str
    aggregations: [],  # a list of aggregation operations, with each agg applied to a column
    overlap_method: str = "intersects",  # spatial predicate to used in spatial join of aoi and data
    # categorical_column_options: str = None,
) -> gpd.GeoDataFrame:
    """
    Create zonal stats for area of interest from data using aggregration operations on data columns.
    Returns the same aoi with additional columns containing the computed zonal features.
    """
    # make data crs == aoi crs
    if not data.crs.equals(aoi.crs):
        data = data.to_crs(aoi.crs)

    # prep for spatial join
    aoi, aoi_index_data, aoi_col_data = prep_aoi(aoi)

    # spatial join - broadcast aoi_index to data => features
    features = gpd.sjoin(
        aoi[["aoi_index", "geometry"]], data, how="inner", predicate=overlap_method
    )

    # group
    groups = features.groupby("aoi_index")
    results = aoi

    # apply aggregations one column at a time
    for agg in aggregations:
        agg = fix_agg(agg)
        results = aggregate_stats(results, groups, agg)

    # cleanup results
    results.drop(labels="aoi_index", inplace=True, axis=1)
    if aoi_index_data:
        results["index"] = aoi_index_data
    if aoi_col_data:
        results["aoi_index"] = aoi_col_data

    return results
