# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/00_validation.ipynb (unless otherwise specified).

__all__ = [
    "ValidationError",
    "Validator",
    "OrientationValidator",
    "CrsBoundsValidator",
    "SelfIntersectingValidator",
    "NullValidator",
    "GeometryValidation",
]

# Internal Cell
import logging
import warnings
from abc import ABC, abstractmethod
from typing import Sequence, Union

import geopandas as gpd
import pandas as pd
from fastcore.basics import patch
from shapely import validation as shapely_validation
from shapely.algorithms.cga import signed_area
from shapely.geometry.base import BaseGeometry
from shapely.geometry.polygon import orient

logger = logging.getLogger(__name__)

# Cell
class ValidationError(Exception):
    pass


# Cell
class Validator(ABC):
    """Abstract Base Class for single validator"""

    fix_available = True
    warning_message = "Geometry errors found"

    def __init__(
        self,
        add_new_column: bool = True,
        apply_fix: bool = True,
    ):
        self.add_new_column = add_new_column
        self.apply_fix = apply_fix

    @property
    @abstractmethod
    def validator_column_name(self):  # pragma: no cover
        pass

    def get_check_arguments(self, gdf: gpd.GeoDataFrame) -> dict:
        return {}

    def check(
        self, geometry: BaseGeometry, gdf: gpd.GeoDataFrame
    ) -> bool:  # pragma: no cover
        pass

    def fix(self, geometry: BaseGeometry):  # pragma: no cover
        pass


@patch
def validate(self: Validator, gdf: gpd.GeoDataFrame, clone=True) -> gpd.GeoDataFrame:
    """Method that checks the validity of a each geometry and applies a fix to these geometries or raise a warning"""
    if clone:
        gdf = gdf.copy()
    check_arguments = self.get_check_arguments(gdf)
    is_valid = gdf.geometry.apply(self.check, **check_arguments)
    if self.add_new_column:
        gdf[self.validator_column_name] = is_valid

    # For cases where no fix is available, run warning instead of applying fixes
    if (not self.fix_available) and (~is_valid.all()):
        warnings.warn(self.warning_message)
    # Fix geometries
    elif self.apply_fix:
        gdf.loc[~is_valid, "geometry"] = gdf[~is_valid].geometry.apply(self.fix)
    return gdf


# Cell


class OrientationValidator(Validator):
    """Checks and fixes Orienation of the geometry to ensure it works for multiple system"""

    validator_column_name = "is_oriented_properly"


@patch
def check(self: OrientationValidator, geometry: BaseGeometry) -> bool:
    """Checks if orientation is counter clockwise"""
    return signed_area(geometry.exterior) >= 0


@patch
def fix(self: OrientationValidator, geometry: BaseGeometry) -> BaseGeometry:
    """Fixes orientation if orientation is clockwise"""
    return orient(geometry)


# Cell


class CrsBoundsValidator(Validator):
    """Checks bounds of the geometry to ensure it is within bounds or crs"""

    validator_column_name = "is_within_crs_bounds"
    fix_available = False
    warning_message = "Found geometries out of bounds from crs"

    def get_check_arguments(self, gdf: gpd.GeoDataFrame) -> dict:
        return {"gdf": gdf}


@patch
def check(
    self: CrsBoundsValidator, geometry: BaseGeometry, gdf: gpd.GeoDataFrame
) -> bool:
    """Checks if polygon is within bounds of crs"""
    xmin, ymin, xmax, ymax = gdf.crs.area_of_use.bounds
    b_xmin, b_ymin, b_xmax, b_ymax = geometry.bounds
    return (
        (b_xmin >= xmin) and (b_ymin >= ymin) and (b_xmax <= xmax) and (b_ymax <= ymax)
    )


@patch
def fix(
    self: CrsBoundsValidator, geometry: BaseGeometry
) -> BaseGeometry:  # pragma: no cover
    """No fix available for CRS Bounds"""
    return geometry


# Cell


class SelfIntersectingValidator(Validator):
    """Checks bounds of the geometry to ensure it is within bounds or crs"""

    validator_column_name = "is_not_self_intersecting"


@patch
def check(self: SelfIntersectingValidator, geometry: BaseGeometry) -> bool:
    explanation = shapely_validation.explain_validity(geometry)
    return "Self-intersection" not in explanation


@patch
def fix(self: SelfIntersectingValidator, geometry: BaseGeometry) -> BaseGeometry:
    """Fix intersection geometry by applying shapely.validation.make_valid"""
    return shapely_validation.make_valid(geometry)


# Cell


class NullValidator(Validator):
    """Checks bounds of the geometry to ensure it is within bounds or crs"""

    validator_column_name = "is_not_null"
    fix_available = False
    warning_message = "Found null geometries"


@patch
def check(self: NullValidator, geometry: BaseGeometry) -> bool:
    """Checks if polygon is within bounds of crs"""
    return not pd.isnull(geometry)


@patch
def fix(
    self: NullValidator, geometry: BaseGeometry
) -> BaseGeometry:  # pragma: no cover
    """No fix available for CRS Bounds"""
    return geometry


# Cell


class GeometryValidation:
    """Applies a list of validation checks and tries to fix them"""

    validators_map = {
        "orientation": OrientationValidator,
        "crs_bounds": CrsBoundsValidator,
        "self_intersecting": SelfIntersectingValidator,
        "null": NullValidator,
    }

    def __init__(
        self,
        gdf: gpd.GeoDataFrame,
        validators: Sequence[Union[str, Validator]] = (
            "orientation",
            "crs_bounds",
            "self_intersecting",
            "null",
        ),
        add_validation_columns: bool = True,
        apply_fixes: bool = True,
    ) -> gpd.GeoDataFrame:
        self.gdf = gdf
        self.validators = validators
        self.add_validation_columns = add_validation_columns
        self.apply_fixes = apply_fixes

    def _get_validators(self) -> Sequence[Validator]:
        """Gets a list of Validator Classes based on string"""
        validators_classes = []
        for validator in self.validators:
            if isinstance(validator, str):
                if validator not in self.validators_map:
                    raise ValidationError("Invalid validator.")
                validator = self.validators_map[validator]
                validators_classes.append(validator)
            else:
                raise ValidationError("Invalid validator.")
        return validators_classes


@patch
def validate_all(self: GeometryValidation) -> gpd.GeoDataFrame:
    """Sequentially run validators"""
    validators = self._get_validators()
    gdf = self.gdf
    for validator in validators:
        gdf = validator(
            add_new_column=self.add_validation_columns,
            apply_fix=self.apply_fixes,
        ).validate(gdf)
    return gdf
