# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/00_validation.ipynb (unless otherwise specified).

__all__ = [
    "ValidationError",
    "Validator",
    "OrientationValidator",
    "CrsBoundsValidator",
    "GeometryValidation",
]

# Internal Cell
import logging
import warnings
from abc import ABC, abstractmethod
from typing import Sequence, Union

import geopandas as gpd
from fastcore.basics import patch
from shapely.algorithms.cga import signed_area
from shapely.geometry.base import BaseGeometry
from shapely.geometry.polygon import orient

logger = logging.getLogger(__name__)

# Cell
class ValidationError(Exception):
    pass


# Cell
class Validator(ABC):
    """Abstract Base Class for single validator"""

    fix_available = True
    warning_message = "Geometry errors found"

    def __init__(
        self,
        add_new_column: bool = True,
        apply_fix: bool = True,
    ):
        self.add_new_column = add_new_column
        self.apply_fix = apply_fix

    @property
    @abstractmethod
    def validator_column_name(self):  # pragma: no cover
        pass

    def get_check_arguments(self, gdf: gpd.GeoDataFrame) -> dict:
        return {}

    def check(
        self, geometry: BaseGeometry, gdf: gpd.GeoDataFrame
    ) -> bool:  # pragma: no cover
        pass

    def fix(self, geometry: BaseGeometry):  # pragma: no cover
        pass


@patch
def validate(self: Validator, gdf: gpd.GeoDataFrame, clone=True) -> gpd.GeoDataFrame:
    """Method that checks the validity of a each geometry and applies a fix to these geometries or raise a warning"""
    if clone:
        gdf = gdf.copy()
    check_arguments = self.get_check_arguments(gdf)
    is_valid = gdf.geometry.apply(self.check, **check_arguments)
    if self.add_new_column:
        gdf[self.validator_column_name] = is_valid

    # For cases where no fix is available, run warning instead of applying fixes
    if (not self.fix_available) and (~is_valid.all()):
        warnings.warn(self.warning_message)
    # Fix geometries
    elif self.apply_fix:
        gdf.loc[~is_valid, "geometry"] = gdf[~is_valid].geometry.apply(self.fix)
    return gdf


# Cell


class OrientationValidator(Validator):
    """Checks and fixes Orienation of the geometry to ensure it works for multiple system"""

    validator_column_name = "is_oriented_properly"


@patch
def check(self: OrientationValidator, geometry: BaseGeometry) -> bool:
    """Checks if orientation is counter clockwise"""
    return signed_area(geometry.exterior) >= 0


@patch
def fix(self: OrientationValidator, geometry: BaseGeometry) -> BaseGeometry:
    """Fixes orientation if orientation is clockwise"""
    return orient(geometry)


# Cell


class CrsBoundsValidator(Validator):
    """Checks bounds of the geometry to ensure it is within bounds or crs"""

    validator_column_name = "is_oriented_properly"
    fix_available = False
    warning_message = "Found geometries out of bounds from crs"

    def get_check_arguments(self, gdf: gpd.GeoDataFrame) -> dict:
        return {"gdf": gdf}


@patch
def check(
    self: CrsBoundsValidator, geometry: BaseGeometry, gdf: gpd.GeoDataFrame
) -> bool:
    """Checks if polygon is within bounds of crs"""
    xmin, ymin, xmax, ymax = gdf.crs.area_of_use.bounds
    b_xmin, b_ymin, b_xmax, b_ymax = geometry.bounds
    return (
        (b_xmin >= xmin) and (b_ymin >= ymin) and (b_xmax <= xmax) and (b_ymax <= ymax)
    )


@patch
def fix(self: CrsBoundsValidator, geometry: BaseGeometry) -> BaseGeometry:
    """No fix available for CRS Bounds"""
    return geometry


# Cell


class GeometryValidation:
    """Applies a list of validation checks and tries to fix them"""

    validators_map = {
        "orientation": OrientationValidator,
        "crs_bounds": CrsBoundsValidator,
    }

    def __init__(
        self,
        gdf: gpd.GeoDataFrame,
        validators: Sequence[Union[str, Validator]] = ("orientation", "crs_bounds"),
        add_validation_columns: bool = True,
        apply_fixes: bool = True,
    ) -> gpd.GeoDataFrame:
        self.gdf = gdf
        self.validators = validators
        self.add_validation_columns = add_validation_columns
        self.apply_fixes = apply_fixes

    def _get_validators(self) -> Sequence[Validator]:
        """Gets a list of Validator Classes based on string"""
        validators_classes = []
        for validator in self.validators:
            if isinstance(validator, str):
                if validator not in self.validators_map:
                    raise ValidationError("Invalid validator.")
                validator = self.validators_map[validator]
                validators_classes.append(validator)
            else:
                raise ValidationError("Invalid validator.")
        return validators_classes


@patch
def validate_all(self: GeometryValidation) -> gpd.GeoDataFrame:
    """Sequentially run validators"""
    validators = self._get_validators()
    gdf = self.gdf
    for validator in validators:
        gdf = validator(
            add_new_column=self.add_validation_columns,
            apply_fix=self.apply_fixes,
        ).validate(gdf)
    return gdf
